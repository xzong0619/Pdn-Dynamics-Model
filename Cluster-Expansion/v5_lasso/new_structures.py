# -*- coding: utf-8 -*-
"""
Created on Mon Feb  4 08:05:11 2019

@author: wangyf
"""
import os 
import pickle
import matplotlib.pyplot as plt 
import matplotlib
import numpy as np
import json
import GA_functions as GA
from ase.visualize import view
from ase.io import read, write



font = {'size'   : 20}

matplotlib.rc('font', **font)
matplotlib.rcParams['axes.linewidth'] = 1.5
matplotlib.rcParams['xtick.major.size'] = 8
matplotlib.rcParams['xtick.major.width'] = 2
matplotlib.rcParams['ytick.major.size'] = 8
matplotlib.rcParams['ytick.major.width'] = 2



with open('ES_iso.json') as f:
    ES_data = json.load(f)
    
Ec = ES_data['E_iso']
config = ES_data['config_iso']
# the number of Pd atoms in each structure
NPd_list = np.array([len(x) for x in config])


# Read the structures generated by GA
nPd_v =     [5, 6, 21]#np.arange(5,21)

# Struture dictionary, keys are number of Pd atoms
new_Pd = dict()
# Energy dictionary, keys are number of Pd atoms
new_E = dict()

for Pdi in nPd_v:
    [new_Pd[Pdi], new_E[Pdi]] = pickle.load(open('pd_'+str(Pdi)+".p", "rb"))


# calculate the value at minimum energy hull
E_Pdi = dict()
E_min = dict()
for Pdi in range(0, max(NPd_list)):
    Pdi = Pdi +1
    Pdi_indices = np.where(np.array(NPd_list) == Pdi)[0]
    E_Pdi[Pdi] = np.array(Ec)[Pdi_indices]
    E_min[Pdi] = np.amin(E_Pdi[Pdi])

new_Pd_min = dict()
new_E_min = dict()
# calculate the structure below minimum energy hull
for Pdi in nPd_v:
    min_indices = np.where(new_E[Pdi] <= E_min[Pdi])[0]
    new_Pd_min[Pdi] =  np.array(new_Pd[Pdi])[min_indices]
    new_E_min[Pdi] = np.array(new_E[Pdi])[min_indices]

  
'''
Plot 1 Cluster Size vs DFT cluster energy
'''

fig, ax = plt.subplots(figsize= (6,5))
ax.scatter(NPd_list, Ec, s=20, facecolors='grey', edgecolors='grey')
ax.plot(E_min.keys(), E_min.values(), '--', c = 'grey')
ax.set_xlabel('Cluster Size N')
ax.set_ylabel('DFT Cluster Energy (eV)')
plt.axis([1, 22, -25, 1])
plt.xticks(np.arange(0, 22, 5))
plt.yticks(np.arange(-25, 5, 5))
plt.show()


'''
Plot 2 Cluster Size vs DFT cluster energy
'''
ns = 20
nPd = nPd_v[0]
fig, ax = plt.subplots(figsize= (6,5))
ax.scatter(NPd_list, Ec, s=20, facecolors='grey', edgecolors='grey', label = 'DFT')
ax.plot(E_min.keys(), E_min.values(), '--', c = 'grey', label = 'DFT min')

for Pdi in nPd_v:
    if Pdi == nPd_v[0]:
        ax.scatter(Pdi * np.ones(ns), new_E[Pdi][:ns], s=20, facecolors='r', edgecolors='r', label = 'GA+CE')
    else:
        ax.scatter(Pdi * np.ones(ns), new_E[Pdi][:ns], s=20, facecolors='r', edgecolors='r')

ax.set_xlabel('Cluster Size N')
ax.set_ylabel('DFT Cluster Energy (eV)')
plt.axis([1, 22, -25, 1])
plt.xticks(np.arange(0, 22, 5))
plt.yticks(np.arange(-25, 5, 5))
plt.legend()
plt.show()



'''
Plot 3 Cluster Size vs DFT cluster energy below energy hull
'''

nPd = nPd_v[0]
fig, ax = plt.subplots(figsize= (6,5))
ax.scatter(NPd_list, Ec, s=20, facecolors='grey', edgecolors='grey', label = 'DFT')
ax.plot(E_min.keys(), E_min.values(), '--', c = 'grey', label = 'DFT min')

for Pdi in nPd_v:
    ns = len(new_E_min[Pdi])
    if Pdi == nPd_v[0]:
        ax.scatter(Pdi * np.ones(ns), new_E_min[Pdi][:ns], s=20, facecolors='r', edgecolors='r', label = 'GA+CE')
    else:
        ax.scatter(Pdi * np.ones(ns), new_E_min[Pdi][:ns], s=20, facecolors='r', edgecolors='r')

ax.set_xlabel('Cluster Size N')
ax.set_ylabel('DFT Cluster Energy (eV)')
plt.axis([1, 22, -25, 1])
plt.xticks(np.arange(0, 22, 5))
plt.yticks(np.arange(-25, 5, 5))
plt.legend()
plt.show()



'''
Plot 4 Cluster Size vs DFT cluster energy selected clusters
'''
n_min = 4
n_total = 0
nPd = nPd_v[0]
fig, ax = plt.subplots(figsize= (6,5))
ax.scatter(NPd_list, Ec, s=20, facecolors='grey', edgecolors='grey', label = 'DFT')
ax.plot(E_min.keys(), E_min.values(), '--', c = 'grey', label = 'DFT min')

for Pdi in nPd_v:
    ns = min(len(new_E_min[Pdi]),n_min)
    n_total = ns + n_total
    if Pdi == nPd_v[0]:
        ax.scatter(Pdi * np.ones(ns), new_E_min[Pdi][:ns], s=20, facecolors='g', edgecolors='g', label = 'GA+CE')
    else:
        ax.scatter(Pdi * np.ones(ns), new_E_min[Pdi][:ns], s=20, facecolors='g', edgecolors='g')

ax.set_xlabel('Cluster Size N')
ax.set_ylabel('DFT Cluster Energy (eV)')
plt.axis([1, 22, -25, 1])
plt.xticks(np.arange(0, 22, 5))
plt.yticks(np.arange(-25, 5, 5))
plt.legend()
plt.show()


# take 3 structure below the minimum energy hull
all_new_Pd = []
all_new_E = []
all_new_atoms = []

for Pdi in nPd_v:
    ns = min(len(new_E_min[Pdi]),n_min)
    all_new_Pd = all_new_Pd + new_Pd[Pdi][:ns]
    all_new_E = all_new_E + new_E[Pdi][:ns]
    
for s in all_new_Pd:
    all_new_atoms.append(GA.ase_object(s))

#view(all_new_atoms[0])
#Pd_ind_fitness = dict()

#%%
new_Pd_dict = dict()
new_E_dict = dict()
new_atoms_dict = dict()
new_count_dict = dict()

for Pdi in nPd_v:
    ns = min(len(new_E_min[Pdi]),n_min)
    new_count_dict[Pdi] = ns
    new_Pd_dict[Pdi] = new_Pd[Pdi][:ns]
    new_E_dict[Pdi] = new_E[Pdi][:ns]
    new_atoms_dict[Pdi] = [GA.ase_object(s) for s in new_Pd[Pdi][:ns]]
    
##%% Save the atom object
#def save_CONTCAR(Pdi, index, atoms):
#
#    Base_path = os.getcwd()
#    filename = 'Pd'+str(Pdi) +'-' + str(index) + '-CONTCAR'
#    output_dir = os.path.join(Base_path, 'outputs_CONTCAR')
#    if not os.path.exists(output_dir): os.makedirs(output_dir)    
#    write(os.path.join(output_dir, filename), atoms)
#
#
#def save_POV(Pdi, index, atoms):
#
#    pov_args = {
#    	'transparent': True, #Makes background transparent. I don't think I've had luck with this option though
#        'canvas_width': 1800., #Size of the width. Height will automatically be calculated. This value greatly impacts POV-Ray processing times
#        'display': False, #Whether you want to see the image rendering while POV-Ray is running. I've found it annoying
#        'rotation': '0x, 0y,0z', #Position of camera. If you want different angles, the format is 'ax, by, cz' where a, b, and c are angles in degrees
#        'celllinewidth': 0.02, #Thickness of cell lines
#        'show_unit_cell': 0 #Whether to show unit cell. 1 and 2 enable it (don't quite remember the difference)
#        #You can also color atoms by using the color argument. It should be specified by an list of length N_atoms of tuples of length 3 (for R, B, G)
#        #e.g. To color H atoms white and O atoms red in H2O, it'll be:
#        #colors: [(0, 0, 0), (0, 0, 0), (1, 0, 0)]
#        }
#
#    #Write to POV-Ray file
#    Base_path = os.getcwd()
#    filename = 'Pd'+str(Pdi) +'-' + str(index) + '.POV'
#    output_dir = os.path.join(Base_path, 'outputs_POV')
#    if not os.path.exists(output_dir): os.makedirs(output_dir)    
#    write(os.path.join(output_dir, filename), atoms, **pov_args)
#
#for Pdi in nPd_v:
#    for index in range(new_count_dict[Pdi]):
#        save_CONTCAR(Pdi, index+1, new_atoms_dict[Pdi][index])
#        save_POV(Pdi, index+1, new_atoms_dict[Pdi][index])